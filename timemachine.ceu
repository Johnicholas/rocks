native @nohold _queue_put();
native @pure   _queue_get();

native do
    enum {
        TM_REQ_PAUSE = -1,
    };
end

#ifndef TM_INPUT_DT
#error Missing "TM_INPUT_DT"
#endif
#ifndef TM_INPUT_FRAME
#error Missing "TM_INPUT_FRAME"
#endif

#define TM_SNAP

interface IIOTimeMachine with
    event void         go_on;
    event void         go_off;
    event _tceu_queue* go_queue;
end

class TimeMachine with
    var App& app;
    var IIOTimeMachine& io;
    event void go_on, go_off;
    //event void ok_restart;

    event int  go_seek;
    event void go_pause;
    event int  go_backward;
    event int  go_forward;

    var   bool seeking? = false;
    event void ok_seek;
    #define TM_AWAIT_SEEK(me)  \
        if me.seeking? then    \
            await me.ok_seek;  \
        end

    var int time_total = 0;
    var int time_now;
do
    _QUEUE_get = 0;

    _SNAP_data := (char*) &this.app;
    _SNAP_put = 0;
    _snap_put(_QUEUE_put, this.time_total);     // 0, 0
#ifdef TM_SNAP
    var int next_snap = _SNAP_ms;
#endif

    loop do
        watching this.go_on do
            var int dt;
            every dt in TM_INPUT_DT do
                this.time_total = this.time_total + dt;
//_printf("DT %d %d\n", this.time_total, this.app.v);
                _assert(dt > 0);
                _queue_put(_CEU_IN__WCLOCK, _CEU_EVTP(dt), 0, null);
#ifdef TM_SNAP
                if this.time_total >= next_snap then
                    next_snap = next_snap + _SNAP_ms;
                    _snap_put(_QUEUE_put, this.time_total);
                end
#endif
            end
        end

        _CEU_TIMEMACHINE_ON = _CEU_TIMEMACHINE_ON + 1;
        emit this.io.go_on;

        par/or do
            finalize with
                _CEU_TIMEMACHINE_ON = _CEU_TIMEMACHINE_ON - 1;
                this.time_total = time_now;     // drop future
                _QUEUE_put = _QUEUE_get;
                _QUEUE_tot = _QUEUE_get;
#ifdef TM_SNAP
                next_snap = _snap_set(time_now);
#endif
            end
            await this.go_off;
            emit this.io.go_off;
        with
            var int speed = 0;
                // initialization avoids valgrind "uninitalized access" below
            event int e_backward;
            var int time_req = _TM_REQ_PAUSE;
            time_now = this.time_total; // start in the end (the current state)
            _QUEUE_get = _QUEUE_put;

            par do
                loop do
                    par/or do
                        var int tmp = await this.go_seek;
                                    // avoid conflict w/ ongoing time_req
                        TM_AWAIT_SEEK(this);
                        time_req = tmp;
                        this.time_now = _snap_get(time_req);
                        speed = 0;
                        //emit this.ok_restart;
                        //_queue_reset();
                    with
                        await this.go_pause;
                        TM_AWAIT_SEEK(this);
                        time_req = _TM_REQ_PAUSE;
                    with
                        var int s = await this.go_backward;
                        TM_AWAIT_SEEK(this);
                        speed = s;
                        emit e_backward => s;
                        await FOREVER;          // e_backward emits go_seek
                    with
                        var int s = await this.go_forward;
                        TM_AWAIT_SEEK(this);
                        speed    = s;
                        time_req = this.time_total;
                    with
                        if speed == 0 then
                            this.seeking? = true;
                        end
#ifndef TM_DELAY
                        var int late = 0;
#endif
/*
TODO: old, remove
                        async (&time_now, speed, time_req, time_total) do
                            loop do
                                if time_req == _TM_REQ_PAUSE then
                                    break;  // already there
                                end
                                var int get = _QUEUE_get;
                                var _tceu_queue[] qu = _queue_get();
                                if qu == null then
                                    break;
                                end
                                //_assert(qu != null);
                                if qu:evt == _CEU_IN__WCLOCK then
                                    var int dt = qu:param.v;
                                    if time_now+dt > time_req then
                                        _QUEUE_get = get;   // undo get
                                        break;  // stop before this emission
                                    end
                                    time_now = time_now + dt;
                                    emit (dt)ms;
                                    emit SDL_DT => dt;
                                    if speed > 0 then
                                        _SDL_Delay(dt/speed);
                                    else/if speed < 0 then
                                        _SDL_Delay(dt*-speed);
                                    end
                                else/if qu:evt == _CEU_IN_SDL_KEYDOWN then
                                    emit SDL_KEYDOWN => qu:param.ptr;
                                else/if qu:evt == _CEU_IN_SDL_KEYUP then
                                    emit SDL_KEYUP => qu:param.ptr;
                                else
                                    _assert(0);
                                end
                                if speed != 0 then
                                    emit SDL_REDRAW;
                                end
                            end
                            emit SDL_REDRAW;
                        end
*/
                        loop do
                            if time_req == _TM_REQ_PAUSE then
                                break;  // already there
                            end
                            var int get = _QUEUE_get;
                            var _tceu_queue[] qu = _queue_get();
                            if qu == null then
                                break;
                            end
                            //_assert(qu != null);
                            if qu:evt == _CEU_IN__WCLOCK then
                                var int dt = qu:param.v;
                                _assert(dt > 0);
                                if time_now+dt > time_req then
                                    _QUEUE_get = get;   // undo get
                                    break;  // stop before this emission
                                end
                                time_now = time_now + dt;

                                if speed != 0 then
                                    var int awt;
                                    if speed > 0 then
                                        awt = dt/speed;
                                    else //  < 0
                                        awt = dt*-speed;
                                    end
#ifdef TM_DELAY
                                    TM_DELAY(awt);
#else
//_printf("AWT: %d %d\n", awt, late);
                                    if awt > late then
//_printf("\tyes\n");
                                        late = await (awt-late) ms_;
                                        _assert(late%1000 == 0);
                                        late = late / 1000;
                                    else
//_printf("\tno\n");
                                        late = late - awt;
                                    end
#endif
                                end

                                async(dt) do
                                    emit (dt)ms;
                                    emit TM_INPUT_DT => dt;
                                end
                            else
                                emit io.go_queue => qu;
                            end
                            if speed != 0 then
                                async do
                                    emit TM_INPUT_FRAME;
                                end
                            end
                        end
                        async do
                            emit TM_INPUT_FRAME;
                        end
/*
*/
                        if this.seeking? then
                            this.seeking? = false;
                            emit this.ok_seek;
                        end
                        await FOREVER;
                    end
                end
            with
                var bool go? = false;
                var int bk_speed;
                loop do
                    var bool me? = false;
                    par/or do
                        // start on this
                        bk_speed = await e_backward;
                        go? = true;
                    with
                        // stop on any of these
                        par/or do
                            await go_seek until (not me?);
                        with
                            await go_pause;
                        with
                            await go_forward;
                        end
                        go? = false;
                    with
/*
TODO: old, remover
                        if not go? then
                            await FOREVER;
                        end
                        var int now = this.time_now;
                        loop i do
                            now = now - 30;
                            if now < 0 then
                                now = 0; // one last time to stop exactly at 0
                            end
                            me? = true;
                            emit this.go_seek => now;   // don't awake myself
                            me? = false;
                            par/and do
                                await this.ok_seek;
                            with
                                var int awt;
                                if bk_speed > 0 then
                                    awt = 30/bk_speed;
                                else/if bk_speed < 0 then
                                    awt = 30*-bk_speed;
                                else
                                    _assert(0);
                                end
                                await (awt)ms_;
                            end
                            if now == 0 then
                                break;
                            end
                        end
                        await FOREVER;
*/
                        if not go? then
                            await FOREVER;
                        end
                        var int now = this.time_now;
//_printf("=======back from now [%d]\n", now);

                        var int awt;
                        if bk_speed > 0 then
                            awt = 30/bk_speed;
                        else/if bk_speed < 0 then
                            awt = 30*-bk_speed;
                        else
                            _assert(0);
                        end
                        await (awt)ms_;             // first iteration

                        loop i do
                            now = now - 30;
                            if now < 0 then
                                now = 0; // one last time to stop exactly at 0
                            end
                            me? = true;
                            emit this.go_seek => now; // don't awake myself (above)
                            me? = false;
                            par/and do
                                await this.ok_seek;
                            with
                                await (awt)ms_;     // other iterations
                            end
                            if now == 0 then
                                break;
                            end
                        end
                        await FOREVER;
/*
*/
                    end
                end
            end
        end
    end

    native do
        typedef struct {
            tceu_nevt evt;
            tceu_evtp param;
            s32       sz;
            byte      buf[0];
        } tceu_queue;

        #define QUEUE_MAX 60*60*1000           \
                          * sizeof(tceu_queue) \
                          / 30 * 2
/*
                            // 60min*60sec*1000ms=(1h in ms)
                            // * minimum size of an event
                            // 30FPS * 2events/frame
            // 1h of events with 2 events/frame
            // 3600*1000 = 3600000 =>/30 = 120000 =>2 = 240000 = 240K events

        #undef QUEUE_MAX
        #define QUEUE_MAX 1000
*/

        byte QUEUE[QUEUE_MAX];
        u32  QUEUE_tot = 0;
        u32  QUEUE_get = 0;
        u32  QUEUE_put = 0;

        int queue_put (tceu_nevt evt, tceu_evtp param,
                               int sz, byte* buf) {
            int n = sizeof(tceu_queue) + sz;

            if (QUEUE_tot+n > QUEUE_MAX) {
                assert(0);
                /*return 0;   TODO: add event FULL when QUEUE_MAX-1 */
            }

            /* An event+data must be continuous in the QUEUE. */
            if (QUEUE_put+n+sizeof(tceu_queue)>=QUEUE_MAX && evt!=CEU_IN__NONE) {
                assert(0);
                int fill = QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
                tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
                qu->evt = CEU_IN__NONE;
                qu->sz  = fill;
                QUEUE_put += sizeof(tceu_queue) + fill;
                QUEUE_tot += sizeof(tceu_queue) + fill;
            }

            {
                tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
                qu->evt = evt;
                qu->sz  = sz;

                if (sz == 0) {
                    /* "param" is self-contained */
                    qu->param = param;
                } else {
                    /* "param" points to "buf" */
                    qu->param.ptr = qu->buf;
                    memcpy(qu->buf, buf, sz);
                }
            }
            QUEUE_put += n;
            QUEUE_tot += n;

            return 1;
        }

        tceu_queue* queue_get (void) {
            if (QUEUE_get == QUEUE_put) {
                return NULL;
            } else {
                assert(QUEUE_tot > 0);
                tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
                QUEUE_get += sizeof(tceu_queue) + qu->sz;
                return qu;
            }
        }

        /**********************************************************************/

        #define SNAP_ms 2000  /* 10s = 30*10 = at most 300 frames to traverse */
                              /* 0 means "do not take snaps" */
#ifdef TM_SNAP
        #define SNAP_N  6*60  /* 10s*6*60=1h  (360*56K-rocks = 1.8Mb) */
#else
        #define SNAP_N  1
#endif

        typedef struct {
            CEU_App data;
            u32     time;
            u32     queue;
        } tceu_snap;

        tceu_snap SNAP[SNAP_N];
        int SNAP_put = 0;
        char* SNAP_data;

        void snap_put (u32 queue, u32 time) {
            assert(SNAP_put < SNAP_N);
            SNAP[SNAP_put].data  = *((CEU_App*)SNAP_data);
            SNAP[SNAP_put].queue = queue;
            SNAP[SNAP_put].time  = time;
            SNAP_put++;
        }

        u32 snap_set (u32 time) {
            int i;
            for (i=0; i<SNAP_put; i++) {
                if (SNAP[i].time > time) {
                    SNAP_put = i;
                    return SNAP[i].time;
                }
            }
            return SNAP[SNAP_put-1].time + SNAP_ms;
        }

        u32 snap_get (u32 time) {
            int i;  /* SNAP[0] is guaranteed to succeed */
            for (i=SNAP_put-1; i>=0; i--) {
                if (SNAP[i].time <= time) {
                    *((CEU_App*)SNAP_data) = SNAP[i].data;
                    QUEUE_get = SNAP[i].queue;
                    return SNAP[i].time;
                }
            }
            assert(0);
        }
    end
end
