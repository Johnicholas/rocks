input int  SDL_DT;
input void SDL_REDRAW;
input _SDL_KeyboardEvent* SDL_KEYDOWN;
input _SDL_KeyboardEvent* SDL_KEYUP;

native @nohold _queue_put();
native @pure   _queue_get();

native do
    enum {
        TM_REQ_PAUSE = -1,
    };
end

class TimeMachine with
    event void go_on, go_off;
    event void ok_restart;

    event (int,bool) go_seek;
    event void       go_pause;
    event int        go_backward;
    event int        go_forward;

    var   bool seeking? = false;
    event void ok;
    #define TM_AWAIT_SEEK(me)  \
        if me.seeking? then    \
            await me.ok;       \
        end

    var int time_total = 0;
    var int time_now;
do
    _queue_reset();
    _snap_reset();

    _snap_put(_QUEUE_put, this.time_total);     // 0, 0
    var int next_snap = _SNAP_ms;
    loop do
        watching this.go_on do
            par do
                var int dt;
                every dt in SDL_DT do
                    _queue_put(_CEU_IN_SDL_DT, _EVTP(dt), 0, null);
                    this.time_total = this.time_total + dt;
                    if this.time_total >= next_snap then
                        next_snap = next_snap + _SNAP_ms;
                        _snap_put(_QUEUE_put, this.time_total);
                    end
                end
            with
                var _SDL_KeyboardEvent* key;
                every key in SDL_KEYDOWN do
                    _queue_put(_CEU_IN_SDL_KEYDOWN, _EVTP(null),
                               sizeof(_SDL_KeyboardEvent), (byte*)key);
                end
            with
                var _SDL_KeyboardEvent* key;
                every key in SDL_KEYUP do
                    _queue_put(_CEU_IN_SDL_KEYUP, _EVTP(null),
                               sizeof(_SDL_KeyboardEvent), (byte*)key);
                end
            end
        end

        _CEU_TIMEMACHINE_ON = _CEU_TIMEMACHINE_ON + 1;

        par/or do
            finalize with
                _CEU_TIMEMACHINE_ON = _CEU_TIMEMACHINE_ON - 1;
                this.time_total = time_now;     // drop future
                _QUEUE_put = _QUEUE_get;
                _QUEUE_tot = _QUEUE_get;
            end
            await this.go_off;
        with
            var int speed;
            event void e_backward;
            var int time_req = _TM_REQ_PAUSE;
            time_now = this.time_total; // start in the end (the current state)
            _QUEUE_get = _QUEUE_put;

            par do
                loop do
                    par/or do
                        var bool xxx;   // dummy
                        var int tmp;    // avoid conflict w/ ongoing time_req
                        (tmp,xxx) = await this.go_seek;
                        TM_AWAIT_SEEK(this);
                        time_req = tmp;
                        this.time_now = _snap_get(time_req);
                        speed = 0;
                        //emit this.ok_restart;
                        //_queue_reset();
                    with
                        await this.go_pause;
                        TM_AWAIT_SEEK(this);
                        time_req = _TM_REQ_PAUSE;
                    with
                        var int s = await this.go_backward;
                        TM_AWAIT_SEEK(this);
                        speed = s;
                        emit e_backward;
                    with
                        var int s = await this.go_forward;
                        TM_AWAIT_SEEK(this);
                        speed    = s;
                        time_req = this.time_total;
                    with
                        if speed == 0 then
                            this.seeking? = true;
                        end
                        async (&time_now, speed, time_req, time_total) do
                            loop do
                                if time_req == _TM_REQ_PAUSE then
                                    break;  // already there
                                else/if time_now >= time_req then
                                    // > possible for bar/backwards imprecision
                                    // do: accept the overflow
                                    // don't: force with "time_now = time_req;"
                                    _assert(time_now <= time_total);
                                    break;  // reached the requested time
                                end
                                var _tceu_queue[] qu = _queue_get();
                                _assert(qu != null);
                                if qu:evt == _CEU_IN_SDL_DT then
                                    var int dt = qu:param.v;
                                    time_now = time_now + dt;
                                    emit (dt)ms;
                                    emit SDL_DT => dt;
                                    if speed > 0 then
                                        _SDL_Delay(dt/speed);
                                    else/if speed < 0 then
                                        _SDL_Delay(dt*-speed);
                                    end
                                else/if qu:evt == _CEU_IN_SDL_KEYDOWN then
                                    emit SDL_KEYDOWN => qu:param.ptr;
                                else/if qu:evt == _CEU_IN_SDL_KEYUP then
                                    emit SDL_KEYUP => qu:param.ptr;
                                else
                                    _assert(0);
                                end
                                if speed != 0 then
                                    emit SDL_REDRAW;
                                end
                            end
                            emit SDL_REDRAW;
                        end
                        if this.seeking? then
                            this.seeking? = false;
                            emit this.ok;
                        end
                        await FOREVER;
                    end
                end
            with
                var bool go? = false;
                var int bk_speed;
                loop do
                    par/or do
                        // start on this
                        await e_backward;
                        go? = true;
                        bk_speed = speed;   // save, successive seeks will overwrite to 0
                    with
                        // stop on any of these
                        par/or do
                            var int xxx;    // dummy
                            var bool bk?;
                            (xxx,bk?) = await go_seek
                                        until (not bk?);
                        with
                            await go_pause;
                        with
                            await go_forward;
                        end
                        go? = false;
                    with
                        if not go? then
                            await FOREVER;
                        end
                        var int now = this.time_now;
                        loop i do
                            if now < 0 then
                                now = 0; // one last time to stop exactly at 0
                            end
                            emit this.go_seek => (now, true);
                            par/and do
                                await this.ok;
                            with
                                var int awt;
                                if bk_speed > 0 then
                                    awt = 30/bk_speed;
                                else/if bk_speed < 0 then
                                    awt = 30*-bk_speed;
                                end
                                await (awt)ms_;
                            end
                            if now == 0 then
                                break;
                            end
                            now = now - 30;
                        end
                        await FOREVER;
                    end
                end
            end
        end
    end
end

native do
    #define EVTP(v) ((tceu_evtp)v)
    #define QUEUE_MAX 60*60*1000/30*2   // 60min*60sec*1000ms=(1h in ms)
                                        // /30=(1h in frames) *2events/frame
        // 1h of events with 2 events/frame
        // 3600*1000 = 3600000 =>/30 = 120000 =>2 = 240000 = 240K events

    typedef struct {
        tceu_nevt evt;
        tceu_evtp param;
        s32       sz;
        byte      buf[0];
    } tceu_queue;

    byte QUEUE[QUEUE_MAX];
    int  QUEUE_tot = 0;
    u32  QUEUE_get = 0;
    u32  QUEUE_put = 0;

    int queue_put (tceu_nevt evt, tceu_evtp param,
                           int sz, byte* buf) {
        int n = sizeof(tceu_queue) + sz;

        if (QUEUE_tot+n > QUEUE_MAX)
            assert(0);
            //return 0;   /* TODO: add event FULL when QUEUE_MAX-1 */

        /* An event+data must be continuous in the QUEUE. */
        if (QUEUE_put+n+sizeof(tceu_queue)>=QUEUE_MAX && evt!=CEU_IN__NONE) {
            int fill = QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
            qu->evt = CEU_IN__NONE;
            qu->sz  = fill;
            QUEUE_put += sizeof(tceu_queue) + fill;
            QUEUE_tot += sizeof(tceu_queue) + fill;
        }

        {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
            qu->evt = evt;
            qu->sz  = sz;

            if (sz == 0) {
                /* "param" is self-contained */
                qu->param = param;
            } else {
                /* "param" points to "buf" */
                qu->param.ptr = qu->buf;
                memcpy(qu->buf, buf, sz);
            }
        }
        QUEUE_put += n;
        QUEUE_tot += n;

        return 1;
    }

    tceu_queue* queue_get (void) {
        if (QUEUE_get == QUEUE_put) {
            return NULL;
        } else {
            assert(QUEUE_tot > 0);
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
            QUEUE_get += sizeof(tceu_queue) + qu->sz;
            return qu;
        }
    }

    void queue_reset (void) {
        QUEUE_get = 0;
    }
end
