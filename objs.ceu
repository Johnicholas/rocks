/*
 * Move the object with constant speed until it goes out of screen.
 * (all objects, except "Ship")
 */
class ObjectMove with
    var Object* obj = null;
    var _float vx = 0;
    var _float vy = 0;
    event void ok;
do
    _assert(this.obj != null);

    var _float sx = obj:rect.x;
    var _float sy = obj:rect.y;

    var int dt;
    every dt=SDL_DT do
        sx = sx + this.vx*dt/1000;
        obj:rect.x = sx;
        if obj:rect.x < 0
        or obj:rect.x > _REN_W then
            break;
        end

        sy = sy + this.vy*dt/1000;
        obj:rect.y = sy;
        if obj:rect.y < 0
        or obj:rect.y > _REN_H then
            break;
        end

        // collisions
        _OBJS[_OBJS_N] := obj;
                       // "nohold": _OBJS_N is reset after SDL_DT on "main"
        _OBJS_N = _OBJS_N + 1;
    end

    emit this.ok;
end

class Fire with
    interface Object;
    var int dir;
    var int vy;
    var int w = 0;  // fire width (may increase with bonus)
do
    this.rect.w = _REN_W/50 + _REN_W*this.w/100;
    this.rect.h = 3;

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = _REN_W/3 * dir;
            this.vy  = vy;
        end;
        await move.ok;
    with
        every SDL_REDRAW do
            _boxRGBA(_REN, rect.x,rect.y, rect.x+rect.w,rect.y+rect.h,
                           0xFF,0xFF,0x88,0xFF);
        end
    with
        await go_hit;
    end
end

#define _SHIP_HITS_MAX  3
#define _SHIP_FIRES_MAX  5
#define _SHIP_SHIELDS_MAX  3

class Ship with
    interface Object;
    var _SDL_Texture* tex = null;

    var int lim_x1, lim_x2, lim_y1, lim_y2;

    var int dir;
    var Controller* controller;

    var int fire_w =  0;

    event void go_shield;
    event void ok_killed;
do
    _assert(this.tex != null);

    var int dim;    // dim = w
        _SDL_QueryTexture(_TEX_SHIP1, null, null, &dim, null);
    this.rect.w = dim;
    this.rect.h = dim;

    var _SDL_Rect clip_r;
        clip_r.x =  0;
        clip_r.w = dim;
        clip_r.h = dim;

    // hits
    var int hits = _SHIP_HITS_MAX;      // number of hit points
    var int blink? = 0;
    var _SDL_Rect hits_r;
        if this.dir > 0 then
            hits_r.x = this.lim_x1 + _REN_W/100;
        else
            hits_r.x = this.lim_x2 - _REN_W/100;
        end
        hits_r.w = _REN_W/100;
        hits_r.y = this.lim_y1 + _REN_H/100;

    // fires
    var int fires = _SHIP_FIRES_MAX;    // number of fires
    var _SDL_Rect fires_r;
        if this.dir > 0 then
            fires_r.x = this.lim_x1 + 2*_REN_W/100;
        else
            fires_r.x = this.lim_x2 - 2*_REN_W/100;
        end
        fires_r.w = _REN_W/100;
        fires_r.y = this.lim_y1 + _REN_H/100;

    // shields
    var int shields = 0;                // number of shields
    var int hasShield? = 0;             // is it active now?
    var _SDL_Rect shields_r;
        if this.dir > 0 then
            shields_r.x = this.lim_x1 + 3*_REN_W/100;
        else
            shields_r.x = this.lim_x2 - 3*_REN_W/100;
        end
        shields_r.w = _REN_W/100;
        shields_r.y = this.lim_y1 + _REN_H/100;

    var _float sx = this.rect.x;
    var _float vx = 0;
    var _float sy = this.rect.y;
    var _float vy = 0;

    par/or do
        // add/sub hit points on "go_hit" (unless "cheat_immortal?")
        // "go_hit" if == 0

#ifdef SDL_SIMUL
        await 10min;
#endif
        loop do
            var int v = await go_hit
                        until not (this.controller:cheat_immortal? or
                                   hasShield?);
            hits = hits + v;

            if v > 0 then
                // don't go over the MAX
                if hits > _SHIP_HITS_MAX then
                    hits = _SHIP_HITS_MAX;
                end
            else
                if hits <= 0 then
                    break;
                end

                // stay immortal for 2s and blink
                _Mix_PlayChannel(-1, _SND_HIT_DEC, 0);
                par/or do
                    every 100ms do
                        blink? = not blink?;
                    end
                with
                    await 2s;
                end
            end
        end
    with
        // a new "fires" every 2s
        every 2s do
            if fires < _SHIP_FIRES_MAX then
                fires = fires + 1;
            end
        end
    with
        // a new "shield"
        every this.go_shield do
            if shields < _SHIP_SHIELDS_MAX then
                shields = shields + 1;
            end
        end
    with
        // spawn shield
        loop do
            await this.controller:ok_shield
            until (shields > 0);

            shields = shields - 1;
            hasShield? = 1;
            finalize with
                this.rect.w = dim;
                this.rect.h = dim;
                hasShield? = 0;
            end

            // explode 40w/s
            _Mix_PlayChannel(-1, _SND_EXPLOSION, 0);
            par/or do
                await 100ms;
            with
                var _float d = this.rect.w;
                var _float v = 40 * this.rect.w;
                var int dt;
                every dt = SDL_DT do
                    d = d + v*dt/1000;
                    this.rect.w = (int)d;
                    this.rect.h = (int)d;
                end
            with
                every SDL_REDRAW do
                    _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w,
                                            0x00,0x00,0xFF,0xDD);
                end
            end
        end
    with
        // spawn a "Fire" every "ok_fired"
        do
            every this.controller:ok_fired do
                if fires == 0 then
                    continue;
                end
                fires = fires - 1;
                var int ok? = spawn[_OBJ_FIRE_N] Fire with
                    this.id   = id + 2;
                    this.dir  = dir;
                    this.vy   = vy;
                    this.rect = rect;
                    this.w    = fire_w;
                end;
                if ok? then
                    _Mix_PlayChannel(-1, _SND_FIRE, 0);
                end
            end
        end
    with
        // move ship up to the screen limits
        var int dt;
        every dt=SDL_DT do
            vx = vx + this.controller:ax*dt;
            vy = vy + this.controller:ay*dt;
            if vx> _REN_W/10 then vx= _REN_W/10; end
            if vx<-_REN_W/10 then vx=-_REN_W/10; end
            if vy> _REN_H/10 then vy= _REN_H/10; end
            if vy<-_REN_H/10 then vy=-_REN_H/10; end

            sx = sx + vx*dt/1000;
            sy = sy + vy*dt/1000;
            if sx < this.lim_x1 then
                sx = this.lim_x1;
                vx = 0;
            else/if sx > this.lim_x2 then
                sx = this.lim_x2;
                vx = 0;
            end
            if sy < this.lim_y1 then
                sy = this.lim_y1;
                vy = 0;
            else/if sy > this.lim_y2 then
                sy = this.lim_y2;
                vy = 0;
            end

            this.rect.x = sx;
            this.rect.y = sy;

            // collisions
            _OBJS[_OBJS_N] := &this;
                           // "nohold": _OBJS_N is reset after SDL_DT on "main"
            _OBJS_N = _OBJS_N + 1;
        end
    with
        every SDL_REDRAW do
            // draw hits
            hits_r.h = hits * _REN_H/20;
            _boxRGBA(_REN, hits_r.x, hits_r.y,
                           hits_r.x+hits_r.w, hits_r.y+hits_r.h,
                           0x00,0xFF,0x00,0x77);
            hits_r.h = _SHIP_HITS_MAX * _REN_H/20;
            _rectangleRGBA(_REN, hits_r.x, hits_r.y,
                                 hits_r.x+hits_r.w, hits_r.y+hits_r.h,
                                 0x77,0x77,0x77,0xFF);

            // draw fires
            fires_r.h = fires * _REN_H/33;
            _boxRGBA(_REN, fires_r.x, fires_r.y,
                           fires_r.x+fires_r.w, fires_r.y+fires_r.h,
                           0xFF,0x00,0x00,0x77);
            fires_r.h = _SHIP_FIRES_MAX * _REN_H/33;
            _rectangleRGBA(_REN, fires_r.x, fires_r.y,
                                 fires_r.x+fires_r.w, fires_r.y+fires_r.h,
                                 0x77,0x77,0x77,0xFF);

            // draw shields
            shields_r.h = shields * _REN_H/33;
            _boxRGBA(_REN, shields_r.x, shields_r.y,
                           shields_r.x+shields_r.w, shields_r.y+shields_r.h,
                           0x00,0x00,0xFF,0xDD);
            shields_r.h = _SHIP_SHIELDS_MAX * _REN_H/33;
            _rectangleRGBA(_REN, shields_r.x, shields_r.y,
                                 shields_r.x+shields_r.w, 
                                 shields_r.y+shields_r.h,
                                 0x77,0x77,0x77,0xFF);

            if blink? then
                continue;
            end

            // choose ship frame
            if this.controller:ay > 0 then
                clip_r.y = dim*3;
            else/if this.controller:ay < 0 then
                clip_r.y = dim*2;
            else/if this.controller:ax * this.dir < 0 then
                clip_r.y = 0;
            else
                clip_r.y = dim*1;
            end
            // redraw sprite
            var _SDL_Rect r;
                r.x = this.rect.x - dim/2;
                r.y = this.rect.y - dim/2;
                r.w = dim;
                r.h = dim;
            _SDL_RenderCopy(_REN, this.tex, &clip_r, &r);
        end
    end

    // explode 40w/s
    _Mix_PlayChannel(-1, _SND_EXPLOSION, 0);
    par/or do
        await 100ms;
    with
        var _float d = dim;
        var _float v = 40 * dim;
        var int dt;
        every dt = SDL_DT do
            d = d + v*dt/1000;
            this.rect.w = (int)d;
            this.rect.h = (int)d;
        end
    with
        every SDL_REDRAW do
            _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w,
                                    0xFF,0x00,0x00,0xFF);
        end
    end

    emit ok_killed;
end

class [_OBJ_ROCK_N] RockBig with
    interface Object;
    var int id = _OBJ_ROCK;
do
    var int dim;    // dim = h
        _SDL_QueryTexture(_TEX_ROCK, null, null, null, &dim);
    this.rect.w = dim;
    this.rect.h = dim;

    var _SDL_Rect clip_r;
        clip_r.x =  0;
        clip_r.y =  0;
        clip_r.w = this.rect.w;
        clip_r.h = this.rect.h;

    var _float vx = _rand()%(_REN_W/5) + 1;
    var _float vy = _rand()%(_REN_H/5) + 1;

    this.rect.x = _REN_W/3 + _rand()%_REN_W/3;
    if _rand() % 2 then
        vx = -vx;
    end
    if _rand() % 2 then
        this.rect.y = 0;
    else
        this.rect.y = _REN_H;
        vy = -vy;
    end

    par/or do
        await (_rand() % 5000)ms;
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        var _float v := _sqrt(vx*vx + vy*vy);
        var _float x = 0;
        var int dt;
        every dt = SDL_DT do
            x = x + v*dt/1000;
            clip_r.x = (int)(x/this.rect.w)*this.rect.w % (6*this.rect.w);
        end
    with
        every SDL_REDRAW do
            var _SDL_Rect r;
                r.x = this.rect.x - this.rect.w/2;
                r.y = this.rect.y - this.rect.h/2;
                r.w = this.rect.w;
                r.h = this.rect.h;
            _SDL_RenderCopy(_REN, _TEX_ROCK, &clip_r, &r);
        end
    with
        await go_hit;
    end
end

class [_OBJ_rock_N] RockSmall with
    interface Object;
    var int id = _OBJ_rock;
    var int dir = 0;
do
    _assert(this.dir != 0);

    var int dim;    // dim = h
        _SDL_QueryTexture(_TEX_rock, null, null, null, &dim);
    this.rect.w = dim;
    this.rect.h = dim;

    var _SDL_Rect clip_r;
        clip_r.x =  0;
        clip_r.y =  0;
        clip_r.w = this.rect.w;
        clip_r.h = this.rect.h;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        var _float v := _sqrt(vx*vx + vy*vy);
        var _float x = 0;
        var int dt;
        every dt = SDL_DT do
            x = x + v*dt/1000;
            clip_r.x = (int)(x/this.rect.w)*this.rect.w % (6*this.rect.w);
        end
    with
        every SDL_REDRAW do
            var _SDL_Rect r;
                r.x = this.rect.x - this.rect.w/2;
                r.y = this.rect.y - this.rect.h/2;
                r.w = this.rect.w;
                r.h = this.rect.h;
            _SDL_RenderCopy(_REN, _TEX_rock, &clip_r, &r);
        end
    with
        await go_hit;
    end
end

class [_OBJ_BONUS_N] Bonus with
    interface Object;
    var int id  = 0;
    var int dir = 0;
    var _SDL_Texture* tex = null;
do
    _assert(this.id  != 0);
    _assert(this.dir != 0);
    _assert(this.tex != null);

    this.rect.w = _REN_W/30;
    this.rect.h = _REN_W/30;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        every SDL_REDRAW do
            _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w/2,
                                    0x00,0x77,0x00,0xFF);

            var _SDL_Rect r;
                _SDL_QueryTexture(this.tex, null, null, &r.w, &r.h);
                r.x = this.rect.x - r.w/2;
                r.y = this.rect.y - r.h/2;
            _SDL_RenderCopy(_REN, this.tex, null, &r);
        end
    with
        await go_hit;
    end
end

class [_OBJ_BOMB_N] Bomb with
    interface Object;
    var int id = _OBJ_BOMB;
    var int dir = 0;
do
    _assert(this.dir != 0);

    this.rect.w = _REN_W/30;
    this.rect.h = _REN_W/30;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    var int timer = 2;  // countdown

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        // countdown 3-2-1-0
        // (or kill)
        par/or do
            var int dt = 500 + _rand() % 2000;
            loop i, 3 do
                await (dt) ms;
                timer = timer - 1;
            end
        with
            await go_hit;
        end

        // collide with ROCK => MAX
        this.id = _OBJ_EXPLOSION;

        // explode 40w/s
        _Mix_PlayChannel(-1, _SND_EXPLOSION, 0);
        par/or do
            await 200ms;
        with
            var _float d = this.rect.w;
            var _float v = 40 * this.rect.w;
            var int dt;
            every dt = SDL_DT do
                d = d + v*dt/1000;
                this.rect.w = (int)d;
                this.rect.h = (int)d;
            end
        end
    with
        every SDL_REDRAW do
            _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w/2,
                                    0xFF,0x00,0x00,0xFF);

            if timer >= 0 then
                var _SDL_Rect r;
                    _SDL_QueryTexture(_TEX_BOMB[timer], null, null,
                                                              &r.w, &r.h);
                    r.x = this.rect.x - r.w/2;
                    r.y = this.rect.y - r.h/2;
                _SDL_RenderCopy(_REN, _TEX_BOMB[timer], null, &r);
            end
        end
    end
end
