/*
 * Move the object with constant speed until it goes out of screen.
 * (all objects, except "Ship")
 */
class ObjectMove with
    var Object* obj = null;
    var _float vx = 0;
    var _float vy = 0;
    event void ok;
do
    _assert(this.obj != null);

    var _float sx = obj:rect.x;
    var _float sy = obj:rect.y;

    var int dt;
    every dt=SDL_DT do
        sx = sx + this.vx*dt/1000;
        obj:rect.x = sx;
        if obj:rect.x < 0
        or obj:rect.x > _REN_W then
            break;
        end

        sy = sy + this.vy*dt/1000;
        obj:rect.y = sy;
        if obj:rect.y < 0
        or obj:rect.y > _REN_H then
            break;
        end

        // collisions
        _OBJS[_OBJS_N] := obj;
                       // "nohold": _OBJS_N is reset after SDL_DT on "main"
        _OBJS_N = _OBJS_N + 1;
    end

    emit this.ok;
end

class Fire with
    interface Object;
    var int dir;
    var int vy;
    var int w = 0;  // fire width (may increase with bonus)
do
    this.rect.w = _REN_W/50 + _REN_W*this.w/150;
    this.rect.h = 3;

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = _REN_W/3 * dir;
            this.vy  = vy;
        end;
        await move.ok;
    with
        every SDL_REDRAW do
            _boxRGBA(_REN, rect.x,rect.y, rect.x+rect.w,rect.y+rect.h,
                           0x77,0x77,0x77,0xFF);
        end
    with
        await go_kill;
    end
end

class Ship with
    interface Object;
    var _SDL_Texture* tex = null;

    var int lim_x1, lim_x2, lim_y1, lim_y2;

    var int dir;
    var Controller* controller;

    var int fire_w = 0;

    event void ok_killed;
do
    _assert(this.tex != null);
    this.rect.w = 30;
    this.rect.h = 30;

    var _SDL_Rect clip;
        clip.x =  0;
        clip.w = 30;
        clip.h = 30;

    var _float sx = this.rect.x;
    var _float vx = 0;
    var _float sy = this.rect.y;
    var _float vy = 0;

    par/or do
        var int dt;
        every dt=SDL_DT do
            vx = vx + this.controller:ax*dt;
            vy = vy + this.controller:ay*dt;
            if vx> _REN_W/10 then vx= _REN_W/10; end
            if vx<-_REN_W/10 then vx=-_REN_W/10; end
            if vy> _REN_H/10 then vy= _REN_H/10; end
            if vy<-_REN_H/10 then vy=-_REN_H/10; end

            sx = sx + vx*dt/1000;
            sy = sy + vy*dt/1000;
            if sx < this.lim_x1 then
                sx = this.lim_x1;
                vx = 0;
            else/if sx > this.lim_x2 then
                sx = this.lim_x2;
                vx = 0;
            end
            if sy < this.lim_y1 then
                sy = this.lim_y1;
                vy = 0;
            else/if sy > this.lim_y2 then
                sy = this.lim_y2;
                vy = 0;
            end

            this.rect.x = sx;
            this.rect.y = sy;

            // collisions
            _OBJS[_OBJS_N] := &this;
                           // "nohold": _OBJS_N is reset after SDL_DT on "main"
            _OBJS_N = _OBJS_N + 1;
        end
    with
        every SDL_REDRAW do
            if this.controller:ay > 0 then
                clip.y = this.rect.w*3;
            else/if this.controller:ay < 0 then
                clip.y = this.rect.w*2;
            else/if this.controller:ax * this.dir < 0 then
                clip.y = 0;
            else
                clip.y = this.rect.w*1;
            end
            var _SDL_Rect r;
                r.x = this.rect.x - this.rect.w/2;
                r.y = this.rect.y - this.rect.h/2;
                r.w = this.rect.w;
                r.h = this.rect.h;
            _SDL_RenderCopy(_REN, this.tex, &clip, &r);
        end
    with
        do
            every this.controller:ok_fired do
                spawn[3] Fire with
                    this.id   = id + 2;
                    this.dir  = dir;
                    this.vy   = vy;
                    this.rect = rect;
                    this.w    = fire_w;
                end;
            end
        end
    with
#ifdef SDL_SIMUL
        await 10min;
#endif
        await go_kill;
    end

    emit ok_killed;
end

class [10] RockBig with
    interface Object;
    var int id = _OBJ_ROCK;
do
    this.rect.w = 30;
    this.rect.h = 30;

    var _SDL_Rect clip;
        clip.x =  0;
        clip.y =  0;
        clip.w = this.rect.w;
        clip.h = this.rect.h;

    var _float vx = _rand()%(_REN_W/5) + 1;
    var _float vy = _rand()%(_REN_H/5) + 1;

    this.rect.x = _REN_W/3 + _rand()%_REN_W/3;
    if _rand() % 2 then
        vx = -vx;
    end
    if _rand() % 2 then
        this.rect.y = 0;
    else
        this.rect.y = _REN_H;
        vy = -vy;
    end

    par/or do
        await (_rand() % 5000)ms;
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        var _float v := _sqrt(vx*vx + vy*vy);
        var _float x = 0;
        var int dt;
        every dt = SDL_DT do
            x = x + v*dt/1000;
            clip.x = (int)(x/this.rect.w)*this.rect.w % (6*this.rect.w);
        end
    with
        every SDL_REDRAW do
            var _SDL_Rect r;
                r.x = this.rect.x - this.rect.w/2;
                r.y = this.rect.y - this.rect.h/2;
                r.w = this.rect.w;
                r.h = this.rect.h;
            _SDL_RenderCopy(_REN, _TEX_ROCK, &clip, &r);
        end
    with
        await go_kill;
    end
end

class [20] RockSmall with
    interface Object;
    var int id = _OBJ_rock;
    var int dir = 0;
do
    _assert(this.dir != 0);

    this.rect.w = 18;
    this.rect.h = 18;

    var _SDL_Rect clip;
        clip.x =  0;
        clip.y =  0;
        clip.w = this.rect.w;
        clip.h = this.rect.h;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        var _float v := _sqrt(vx*vx + vy*vy);
        var _float x = 0;
        var int dt;
        every dt = SDL_DT do
            x = x + v*dt/1000;
            clip.x = (int)(x/this.rect.w)*this.rect.w % (6*this.rect.w);
        end
    with
        every SDL_REDRAW do
            var _SDL_Rect r;
                r.x = this.rect.x - this.rect.w/2;
                r.y = this.rect.y - this.rect.h/2;
                r.w = this.rect.w;
                r.h = this.rect.h;
            _SDL_RenderCopy(_REN, _TEX_rock, &clip, &r);
        end
    with
        await go_kill;
    end
end

class [5] BonusLife with
    interface Object;
    var int id = _OBJ_BONUS_LIFE;
    var int dir = 0;
do
    _assert(this.dir != 0);

    this.rect.w = _REN_W/50;
    this.rect.h = _REN_W/50;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        every SDL_REDRAW do
            _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w,
                                    0x00,0x77,0x00,0xFF);

            var _SDL_Rect r;
                _SDL_QueryTexture(_TEX_BONUS_LIFE, null, null, &r.w, &r.h);
                r.x = (int) _UI_align(this.rect.x, r.w, _UI_ALIGN_CENTER);
                r.y = (int) _UI_align(this.rect.y, r.h, _UI_ALIGN_MIDDLE);
            _SDL_RenderCopy(_REN, _TEX_BONUS_LIFE, null, &r);
        end
    with
        await go_kill;
    end
end

class [5] BonusFire with
    interface Object;
    var int id  = _OBJ_BONUS_FIRE;
    var int dir = 0;
do
    _assert(this.dir != 0);

    this.rect.w = _REN_W/50;
    this.rect.h = _REN_W/50;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        every SDL_REDRAW do
            _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w,
                                    0x00,0x77,0x00,0xFF);

            var _SDL_Rect r;
                _SDL_QueryTexture(_TEX_BONUS_FIRE, null, null, &r.w, &r.h);
                r.x = (int) _UI_align(this.rect.x, r.w, _UI_ALIGN_CENTER);
                r.y = (int) _UI_align(this.rect.y, r.h, _UI_ALIGN_MIDDLE);
            _SDL_RenderCopy(_REN, _TEX_BONUS_FIRE, null, &r);
        end
    with
        await go_kill;
    end
end

class [5] BonusBomb with
    interface Object;
    var int id = _OBJ_BONUS_BOMB;
    var int dir = 0;
do
    _assert(this.dir != 0);

    this.rect.w = _REN_W/50;
    this.rect.h = _REN_W/50;

    var _float vx = (_rand()%(_REN_W/10) + 1) * this.dir;
    var _float vy = (_rand()%(_REN_H/10) + 1);
    if _rand() % 2 then
        vy = -vy;
    end

    var int timer = 2;  // countdown

    par/or do
        var Object* obj = &this;
        var ObjectMove move with
            this.obj = obj;
            this.vx  = vx;
            this.vy  = vy;
        end;
        await move.ok;
    with
        // countdown 3-2-1-0
        // (or kill)
        par/or do
            var int dt = 500 + _rand() % 2000;
            loop i, 3 do
                await (dt) ms;
                timer = timer - 1;
            end
        with
            await go_kill;
        end

        // explode x 5*d
        par/or do
            await 100ms;
        with
            var _float d = this.rect.w;
            var _float v = 50 * this.rect.w;
            var int dt;
            every dt = SDL_DT do
                d = d + v*dt/1000;
                this.rect.w = (int)d;
                this.rect.h = (int)d;
            end
        end
    with
        every SDL_REDRAW do
            _filledCircleRGBA(_REN, this.rect.x,this.rect.y,this.rect.w,
                                    0xFF,0x00,0x00,0xFF);

            if timer >= 0 then
                var _SDL_Rect r;
                    _SDL_QueryTexture(_TEX_BONUS_BOMB[timer], null, null,
                                                              &r.w, &r.h);
                    r.x = (int) _UI_align(this.rect.x, r.w, _UI_ALIGN_CENTER);
                    r.y = (int) _UI_align(this.rect.y, r.h, _UI_ALIGN_MIDDLE);
                _SDL_RenderCopy(_REN, _TEX_BONUS_BOMB[timer], null, &r);
            end
        end
    end
end
