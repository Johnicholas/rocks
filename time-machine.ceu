native do
    #define EVTP(v) ((tceu_evtp)v)
    #define QUEUE_MAX 3000000

    typedef struct {
        tceu_nevt evt;
        tceu_evtp param;
        s32       sz;
        byte      buf[0];
    } tceu_queue;

    byte QUEUE[QUEUE_MAX];
    int  QUEUE_tot = 0;
    u32  QUEUE_get = 0;
    u32  QUEUE_put = 0;

    int queue_put (tceu_nevt evt, tceu_evtp param,
                           int sz, byte* buf) {
        int n = sizeof(tceu_queue) + sz;

        if (QUEUE_tot+n > QUEUE_MAX)
            assert(0);
            //return 0;   /* TODO: add event FULL when QUEUE_MAX-1 */

        /* An event+data must be continuous in the QUEUE. */
        if (QUEUE_put+n+sizeof(tceu_queue)>=QUEUE_MAX && evt!=CEU_IN__NONE) {
            int fill = QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
            qu->evt = CEU_IN__NONE;
            qu->sz  = fill;
            QUEUE_put += sizeof(tceu_queue) + fill;
            QUEUE_tot += sizeof(tceu_queue) + fill;
        }

        {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
            qu->evt = evt;
            qu->sz  = sz;

            if (sz == 0) {
                /* "param" is self-contained */
                qu->param = param;
            } else {
                /* "param" points to "buf" */
                qu->param.ptr = qu->buf;
                memcpy(qu->buf, buf, sz);
            }
        }
        QUEUE_put += n;
        QUEUE_tot += n;

        return 1;
    }

    tceu_queue* queue_get (void) {
        tceu_queue* ret;
        if (QUEUE_get == QUEUE_put) {
            ret = NULL;
        } else {
            assert(QUEUE_tot > 0);
            ret = (tceu_queue*) &QUEUE[QUEUE_get];
        }
        return ret;
    }

    void queue_nxt (void) {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
        //QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
        QUEUE_get += sizeof(tceu_queue) + qu->sz;
    }

    void queue_reset (void) {
        QUEUE_get = 0;
    }
end

#include "sdl.ceu"
#include "sdl-gfx.ceu"

input void SDL_QUIT;
input int  SDL_DT;
input void SDL_REDRAW, SDL_REDRAW_;
input _SDL_KeyboardEvent* SDL_KEYDOWN;
input _SDL_KeyboardEvent* SDL_KEYUP;
input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN_;

native @nohold _queue_put();
native @pure   _queue_get();

class TimeMachine with
    event void go_on, go_off;
    event void ok_restart;

    event (int,bool) go_seek;
    event int  go_backward;
    event int  go_forward;
    event void ok;

    var int time_total = 0;
    var int time_now;
do
    loop do
        watching this.go_on do
            par do
                var int dt;
                every dt in SDL_DT do
                    _queue_put(_CEU_IN_SDL_DT, _EVTP(dt), 0, null);
                    this.time_total = this.time_total + dt;
                end
            with
                var _SDL_KeyboardEvent* key;
                every key in SDL_KEYDOWN do
                    _queue_put(_CEU_IN_SDL_KEYDOWN, _EVTP(null),
                               sizeof(_SDL_KeyboardEvent), (byte*)key);
                end
            with
                var _SDL_KeyboardEvent* key;
                every key in SDL_KEYUP do
                    _queue_put(_CEU_IN_SDL_KEYUP, _EVTP(null),
                               sizeof(_SDL_KeyboardEvent), (byte*)key);
                end
            end
        end

        _CEU_TIMEMACHINE_ON = true;
        finalize with
            _CEU_TIMEMACHINE_ON = false;
        end
        watching this.go_off do
            this.time_now = time_total;
            var int time_req = this.time_total;
            var int speed;
            _queue_reset();

            event void e_backward;

            par do
                var bool bk? = false;
                loop do
                    par/or do
                        (time_req,bk?) = await this.go_seek;
                        emit this.ok_restart;
                        this.time_now = 0;
                        speed = 0;
                        _queue_reset();
                    with
                        speed = await this.go_backward;
                        emit e_backward;
                    with
                        speed = await this.go_forward;
                        time_req = this.time_total;
                    with
                        async (&time_now, speed, time_req) do
                            loop do
                                if this.time_now >= time_req then
                                    break;
                                end
                                var _tceu_queue[] qu = _queue_get();
                                if qu == null then
                                    break;
                                end
                                if qu:evt == _CEU_IN_SDL_DT then
                                    var int dt = qu:param.v;
                                    emit (dt)ms;
                                    emit SDL_DT => dt;
                                    this.time_now = this.time_now + dt;
                                    if speed > 0 then
                                        _SDL_Delay(dt/speed);
                                    else/if speed < 0 then
                                        _SDL_Delay(dt*-speed);
                                    end
                                else/if qu:evt == _CEU_IN_SDL_KEYDOWN then
                                    emit SDL_KEYDOWN => qu:param.ptr;
                                else/if qu:evt == _CEU_IN_SDL_KEYUP then
                                    emit SDL_KEYUP => qu:param.ptr;
                                else
                                    _assert(0);
                                end
                                if speed != 0 then
                                    emit SDL_REDRAW;
                                end
                                _queue_nxt();
                            end
                            emit SDL_REDRAW;
                        end
                        emit this.ok;
                        await FOREVER;
                    end
                end
            with
                var bool go? = false;
                var int bk_speed;
                loop do
                    par/or do
                        // start on this
                        await e_backward;
                        go? = true;
                        bk_speed = speed;   // save, successive seeks will overwrite to 0
                    with
                        // stop on any of these
                        par/or do
                            var int t;
                            var bool bk?;
                            (t,bk?) = await go_seek until (not bk?);
                        with
                            await go_forward;
                        end
                        go? = false;
                    with
                        if not go? then
                            await FOREVER;
                        end
                        var int now = this.time_now;
                        loop i do
                            if now < 0 then
                                now = 0; // one last time to stop exactly at 0
                            end
                            emit this.go_seek => (now,true);
                            par/and do
                                await this.ok;
                            with
                                var int awt;
                                if bk_speed > 0 then
                                    awt = 30/bk_speed;
                                else/if bk_speed < 0 then
                                    awt = 30*-bk_speed;
                                end
                                await (awt)ms_;
                            end
                            if now == 0 then
                                break;
                            end
                            now = now - 30;
                        end
                        await FOREVER;
                    end
                end
            end
        end
    end
end

native do
    SDL_Texture* TEX_PLAY    = NULL;
    SDL_Texture* TEX_STOP    = NULL;
    SDL_Texture* TEX_PAUSE   = NULL;
    SDL_Texture* TEX_FORWARD = NULL;
    SDL_Texture* TEX_REWIND  = NULL;
    SDL_Texture* TEXS[5];
end

finalize
   _TEX_PLAY = _IMG_LoadTexture(_REN, "tm/play.png");
with
   _SDL_DestroyTexture(_TEX_PLAY);
end
finalize
   _TEX_STOP = _IMG_LoadTexture(_REN, "tm/stop.png");
with
   _SDL_DestroyTexture(_TEX_STOP);
end
finalize
   _TEX_PAUSE = _IMG_LoadTexture(_REN, "tm/pause.png");
with
   _SDL_DestroyTexture(_TEX_PAUSE);
end
finalize
   _TEX_FORWARD = _IMG_LoadTexture(_REN, "tm/forward.png");
with
   _SDL_DestroyTexture(_TEX_FORWARD);
end
finalize
   _TEX_REWIND = _IMG_LoadTexture(_REN, "tm/rewind.png");
with
   _SDL_DestroyTexture(_TEX_REWIND);
end
_assert(_TEX_PLAY    != null);
_assert(_TEX_STOP    != null);
_assert(_TEX_PAUSE   != null);
_assert(_TEX_FORWARD != null);
_assert(_TEX_REWIND  != null);
_TEXS[0] = _TEX_REWIND;
_TEXS[1] = _TEX_STOP;
_TEXS[2] = _TEX_PLAY;
_TEXS[3] = _TEX_PAUSE;
_TEXS[4] = _TEX_FORWARD;

class UITimeMachine with
    var TimeMachine& tm;

    event void go_on, go_off;
    event void ok_restart;

    event void go_redraw;
do
    input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN_;
    input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONUP_;
    input _SDL_MouseMotionEvent* SDL_MOUSEMOTION_;

    var int x = _REN_W/4;
    var int w = _REN_W - x*2;
    var int h = _REN_H/80;
    var int y = _REN_H - h*2;

    var _SDL_Rect r;
        r.x = x;
        r.y = y;
        r.w = w;
        r.h = h;

    var _SDL_Rect rc;
        rc.w = w*2 / 3;
        rc.x = _REN_W/2 - rc.w/2;
        rc.y = y - _REN_H/10 - _REN_H/80;
        rc.h = _REN_H/10;

    var _SDL_Rect[5] rcs;
    do
        var int dx = rc.w / 6;
        loop i in 5 do
            var _SDL_Rect ri;
            _SDL_QueryTexture(_TEXS[i], null, null, &ri.w, &ri.h);
            ri.x = rc.x + (i+1)*dx - ri.w/2;
            ri.y = rc.y + (rc.h-ri.h)/2;
            rcs[i] = ri;
        end
    end

    loop do
        await this.go_on;
        var int bk_speed = -4;
        var int fw_speed = -4;
        par/or do
            await this.go_off;
        with
            loop do
                var _SDL_MouseButtonEvent* e = await SDL_MOUSEBUTTONDOWN_
                                               until _SDL_Rect_vs_Mouse(&r,e);
                emit tm.go_seek => (tm.time_total * (e:x-x) / w, false);
                bk_speed = -4;
                fw_speed = -4;
                watching SDL_MOUSEBUTTONUP_ do
                    loop do
                        par/and do
                            await tm.ok;
                        with
                            await SDL_MOUSEMOTION_;
                        end
                        var int x_,y_;
                        _SDL_GetMouseState(&x_, &y_);
                        emit tm.go_seek => (tm.time_total * (x_-x) / w, false);
                    end
                end
            end
        with
            loop do
                var _SDL_MouseButtonEvent* e = await SDL_MOUSEBUTTONDOWN_;
                var int i = -1;
                loop ii in 5 do
                    if _SDL_Rect_vs_Mouse(&rcs[ii], e) then
                        i = ii;
                        break;
                    end
                end
                e = await SDL_MOUSEBUTTONUP_;
                if _SDL_Rect_vs_Mouse(&rcs[i], e) then
                    if i == 0 then
                        emit tm.go_backward => bk_speed;
                        bk_speed = bk_speed + 1;
                        if bk_speed == 0 then
                            bk_speed = 1;   // skip seek speed 0
                        end
                    else/if i == 1 then     // stop
                        emit tm.go_seek => (0, false);
                    else/if i == 2 then     // play
                        emit tm.go_forward => 1;
                    else/if i == 3 then     // pause
                        emit tm.go_seek => (tm.time_now, false);
                    else/if i == 4 then     // forward
                        emit tm.go_forward => fw_speed;
                        fw_speed = fw_speed + 1;
                        if fw_speed == 0 then
                            fw_speed = 1;   // skip seek speed 0
                        end
                    end
                    if i != 0 then
                        bk_speed = -4;  // reset fw_speed for other clicks
                    end
                    if i != 4 then
                        fw_speed = -4;  // reset fw_speed for other clicks
                    end
                end
            end
        with
            every this.go_redraw do
                do
                    var int dx = ((float)tm.time_now)/tm.time_total * w;
                    _boxRGBA(_REN, x, y, x+w, y+h,
                                   0x88,0x88,0x88,0x88);
                    _filledCircleRGBA(_REN, x+dx-h/2, y+h/2, h,
                                            0xFF,0xFF,0xFF,0x88);
                end
                do
                    _boxRGBA(_REN, rc.x, rc.y, rc.x+rc.w, rc.y+rc.h,
                             0xAA,0xAA,0xAA,0xAA);
                    loop i in 5 do
                        _SDL_RenderCopy(_REN, _TEXS[i], null, &rcs[i]);
                    end
                end
            end
        end
    end
end
