native do
    #define EVTP(v) ((tceu_evtp)v)
    #define QUEUE_MAX 3000000

    typedef struct {
        tceu_nevt evt;
        tceu_evtp param;
        s32       sz;
        byte      buf[0];
    } tceu_queue;

    byte QUEUE[QUEUE_MAX];
    int  QUEUE_tot = 0;
    u32  QUEUE_get = 0;
    u32  QUEUE_put = 0;

    int queue_put (tceu_nevt evt, tceu_evtp param,
                           int sz, byte* buf) {
        int n = sizeof(tceu_queue) + sz;

        if (QUEUE_tot+n > QUEUE_MAX)
            assert(0);
            //return 0;   /* TODO: add event FULL when QUEUE_MAX-1 */

        /* An event+data must be continuous in the QUEUE. */
        if (QUEUE_put+n+sizeof(tceu_queue)>=QUEUE_MAX && evt!=CEU_IN__NONE) {
            int fill = QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
            qu->evt = CEU_IN__NONE;
            qu->sz  = fill;
            QUEUE_put += sizeof(tceu_queue) + fill;
            QUEUE_tot += sizeof(tceu_queue) + fill;
        }

        {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
            qu->evt = evt;
            qu->sz  = sz;

            if (sz == 0) {
                /* "param" is self-contained */
                qu->param = param;
            } else {
                /* "param" points to "buf" */
                qu->param.ptr = qu->buf;
                memcpy(qu->buf, buf, sz);
            }
        }
        QUEUE_put += n;
        QUEUE_tot += n;

        return 1;
    }

    tceu_queue* queue_get (void) {
        tceu_queue* ret;
        if (QUEUE_get == QUEUE_put) {
            ret = NULL;
        } else {
            assert(QUEUE_tot > 0);
            ret = (tceu_queue*) &QUEUE[QUEUE_get];
        }
        return ret;
    }

    void queue_nxt (void) {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
        //QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
        QUEUE_get += sizeof(tceu_queue) + qu->sz;
    }

    void queue_reset (void) {
        QUEUE_get = 0;
    }
end

#include "sdl.ceu"

input void SDL_QUIT;
input int  SDL_DT;
input void SDL_REDRAW, SDL_REDRAW_;
input _SDL_KeyboardEvent* SDL_KEYDOWN;
input _SDL_KeyboardEvent* SDL_KEYUP;
input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN_;

native @nohold _queue_put();
native @pure   _queue_get();

class Play with
    event void go_on, go_off;
    event void go_redraw;
    event void ok_restart;
do
    var int time_total = 0;

    loop do
        _CEU_TIMEMACHINE_ON = false;
        watching this.go_on do
            par do
                var int dt;
                every dt in SDL_DT do
                    _queue_put(_CEU_IN_SDL_DT, _EVTP(dt), 0, null);
                    time_total = time_total + dt;
                end
            with
                var _SDL_KeyboardEvent* key;
                every key in SDL_KEYDOWN do
                    _queue_put(_CEU_IN_SDL_KEYDOWN, _EVTP(null),
                               sizeof(_SDL_KeyboardEvent), (byte*)key);
                end
            with
                var _SDL_KeyboardEvent* key;
                every key in SDL_KEYUP do
                    _queue_put(_CEU_IN_SDL_KEYUP, _EVTP(null),
                               sizeof(_SDL_KeyboardEvent), (byte*)key);
                end
            end
        end

        _CEU_TIMEMACHINE_ON = true;
        watching this.go_off do
            event (int,int) go_seek;
            event void go_resume;
            event void ok_seek;

            var int time_now = time_total;
            par do
                var int time_req = time_total;
                var int speed    = 0;
                var bool resume? = false;
                _queue_reset();
                loop do
                    par/or do
                        (speed, time_req) = await go_seek;
//var int t = _SDL_GetTicks();
                        emit this.ok_restart;
//_printf("RESTART = %d\n", _SDL_GetTicks()-t);
                        time_now = 0;
                        resume? = false;
                        _queue_reset();
                    with
                        await go_resume;
                        resume? = true;
                    with
//var int t = _SDL_GetTicks();
//_printf("seeking\n");
                        async (&time_now, speed, time_req) do
                            loop do
                                var _tceu_queue[] qu = _queue_get();
                                if qu == null then
                                    break;
                                end
                                if time_now >= time_req then
                                    break;
                                end
                                if qu:evt == _CEU_IN_SDL_DT then
                                    var int dt = qu:param.v;
                                    emit (dt)ms;
                                    emit SDL_DT => dt;
                                    time_now = time_now + dt;
                                    if speed > 0 then
                                        _SDL_Delay(dt/speed);
                                    else/if speed < 0 then
                                        _SDL_Delay(dt*-speed);
                                    end
                                else/if qu:evt == _CEU_IN_SDL_KEYDOWN then
                                    emit SDL_KEYDOWN => qu:param.ptr;
                                else/if qu:evt == _CEU_IN_SDL_KEYUP then
                                    emit SDL_KEYUP => qu:param.ptr;
                                else
                                    _assert(0);
                                end
                                if speed != 0 then
                                    emit SDL_REDRAW;
                                end
                                _queue_nxt();
                            end
                            emit SDL_REDRAW;
                        end
//_printf("SEEK = %d\n", _SDL_GetTicks()-t);
                        emit ok_seek;

                        // only allow resume after completing
                        if resume? then
                            speed = 2;
                            time_req = time_total;
                            resume? = false;
                        else
                            await FOREVER;
                        end
                    end
                end
            with
                var int x = _REN_W/4;
                var int w = _REN_W - x*2;
                var int h = _REN_H/80;
                var int y = _REN_H - h*2;

                var _SDL_Rect r;
                    r.x = x;
                    r.y = y;
                    r.w = w;
                    r.h = h;

                par do
                    input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN_;
                    input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONUP_;
                    input _SDL_MouseMotionEvent* SDL_MOUSEMOTION_;
                    loop do
                        var _SDL_MouseButtonEvent* e = await SDL_MOUSEBUTTONDOWN_
                                                       until _SDL_Rect_vs_Mouse(&r,e);
                        emit go_seek => (0, time_total * (e:x-x) / w);
                        watching SDL_MOUSEBUTTONUP_ do
                            loop do
                                par/and do
                                    await ok_seek;
                                with
                                    await SDL_MOUSEMOTION_;
                                end
                                var int x_,y_;
                                _SDL_GetMouseState(&x_, &y_);
                                emit go_seek => (0, time_total * (x_-x) / w);
                            end
                        end

                        //var int x_,y_;
                        //_SDL_GetMouseState(&x_, &y_);
                        //emit this.ok_restart;
                        //emit go_seek => (0, time_total * (x_-x) / w);
                        emit go_resume;
                    end
                with
//do await FOREVER; end
                    loop i do
                        var int t = time_total - i*30;
                        if t < 0 then
                            break;
                        end
                        emit go_seek => (0, t);
                        //par/and do
                            await ok_seek;
                        //with
                            //await 30ms; // TODO: speed
                        //end
                    end
                    await FOREVER;
                with
                    every this.go_redraw do
                        var int dx = ((float)time_now)/time_total * w;
                        _boxRGBA(_REN, x, y, x+w, y+h,
                                       0x88,0x88,0x88,0x88);
                        _filledCircleRGBA(_REN, x+dx, y+h/2, h,
                                                0xFF,0xFF,0xFF,0x88);
                    end
                end
            end
        end
    end
end
